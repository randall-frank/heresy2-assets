import argparse
import datetime
from functools import partial
import json
import threading
import tomllib
import webbrowser
import zipfile
from http.server import SimpleHTTPRequestHandler, HTTPServer
import logging
import os
import platform
import shutil
import stat
import subprocess
import requests

try:
    import git
    repo = git.Repo(".")
    branch_name = repo.active_branch.name
    branch_sha = repo.active_branch.commit.hexsha
    __version_git__ = f"Source: {branch_name}:{branch_sha}"
except:
    __version_git__ = ""


# Get the current version number
with open("version.txt", "r") as f:
    __version__ = f.read().strip()
    
# Get the current time/date
__version_date__ = datetime.datetime.now().isoformat(timespec='minutes', sep=" ") 
    
"""
Command line build tool:

python build.py [operation] [options]

Operations:

clean
build
release
serve [--port port] [--nobrowser]

Note:

The 'inklecate' tool needs to be in the search path
and executable.  If it is not in the search path,
set HERESY2_INKLECATE to the complete pathname to the
executable.

"""


def build_story_js() -> None:
    """
    Rebuild the heresy2.js file in the build directory.

    First build the item_globals.ink and item_globals.js files
    from the items.toml file.

    :return:
    """
    # Get the story version
    with open("version.txt", "rb") as fp:
        version = fp.read()
    log.info(f"Story version: {version.decode('ascii')}")
    copyright_year = str(datetime.datetime.now().year).encode("utf8")
    # Generate the items content
    with open(os.path.join("src", "items.toml"), "r") as fp:
        info = tomllib.loads(fp.read())
    # create items_globals.js
    js = json.dumps(info)
    with open(os.path.join("build", "js", "item_globals.js"), "w", encoding='utf-8') as fp:
        fp.write(f"var storyItems = {js};\n")
        fp.write("var theStory = null;\n")
        fp.write("var audio = null;\n")
        fp.write("var audioLoop = null;\n")
        fp.write("let current_volume = 30;\n")
        fp.write("let last_volume = 30;\n")
        fp.write("var story_version = '" + version.decode('ascii') + "';\n")
    # create items_globals.ink
    with open(os.path.join("src", "item_globals.ink"), "w") as fp:
        fp.write("// This file is autogenerated from 'items.toml'.\n")
        fp.write("// Do not edit this file.\n")
        fp.write("\n// Items:\n")
        for name, data in info["items"].items():
            fp.write(f"VAR {name} = 0\n")
        fp.write("\n// States:\n")
        for name, data in info["states"].items():
            fp.write(f"VAR {name} = {data['default']}\n")
    # Generate the .json format of the root ink file
    inklecate_path = find_inklecate()
    cmd = [inklecate_path, "-o", "tmp.json", "-j", "-v", os.path.join("src", "heresy2.ink")]
    log.debug(f"Running compiler: {cmd}\n")
    try:
        result = subprocess.run(cmd, stdout=subprocess.PIPE)
    except FileNotFoundError:
        log.error(f"Could not run inklecate using path: {inklecate_path}.\nCheck your system PATH or HERESY2_INKLECATE environmental variable.")
        exit(-1)
    log.info(result.stdout.decode('utf-8'))
    # Build the Javascript from the JSON content
    with open("tmp.json", "rb") as fp:
        s = fp.read()
        s = b"var storyContent = " + s
        s = s.replace(b"STORY_VERSION", version)
        s = s.replace(b"STORY_YEAR", copyright_year)
        s = s.replace(b"STORY_GIT_BRANCH", __version_git__.encode("utf8"))
        s = s.replace(b"STORY_BUILD_DATE", __version_date__.encode("utf8"))
        with open(os.path.join("build", "js", "heresy2.js"), "wb") as output:
            output.write(s)


def download_file(url, filename) -> bool:
    """Download a file from a given URL and save it to a specified filename.
    :param url: str The URL to download the file from.
    :param filename: str The local filename to save the downloaded file.
    :return: bool True if the download was successful, False otherwise.
    """
    try:
        # Send a GET request to the URL, enabling streaming for large files
        response = requests.get(url, stream=True)
        response.raise_for_status()  # Raise an HTTPError for bad responses (4xx or 5xx)

        # Open the local file in binary write mode
        with open(filename, 'wb') as file:
            # Iterate over content in chunks to handle large files efficiently
            for chunk in response.iter_content(chunk_size=8192):
                file.write(chunk)
        log.info(f"File '{filename}' downloaded successfully from '{url}'")
        return True
    except requests.exceptions.RequestException as e:
        log.warning(f"Error downloading file from '{url}': {e}")
        return False


def download_inklecate(exe_name: str) -> str:
    """
    Download the inklecate CLI tool from the official repository if it is not found in the "ink_tools" directory.
    :param exe_name: str The name of the executable file to download (e.g., "inklecate.exe" or "inklecate").
    :return: str The path to the downloaded inklecate executable.
    """
    # if "ink_tools/exe_name" exists, return that pathname, otherwise, rebuild the directory
    full_name = os.path.join("ink_tools", exe_name)
    if os.path.exists(full_name):
        return full_name
    try:
        shutil.rmtree("ink_tools")
    except OSError:
        pass
    os.mkdir("ink_tools")
    url = "https://github.com/inkle/ink/releases/download/v.1.2.0/inklecate_windows.zip"
    zip_filename = os.path.join("ink_tools", "inklecate_windows.zip")
    if platform.system().lower().startswith("linux"):
        url = "https://github.com/inkle/ink/releases/download/v.1.2.0/inklecate_linux.zip"
        zip_filename = os.path.join("ink_tools", "inklecate_linux.zip")
    if not download_file(url, zip_filename):
        raise RuntimeError("Unable to download the inklecate CLI tools.")
    try:
        with zipfile.ZipFile(zip_filename, 'r') as zip_ref:
            zip_ref.extractall("ink_tools")
        log.info(f"All files extracted from '{zip_filename}' to 'ink_tools'.")
    except zipfile.BadZipFile:
        log.error(f"Error: '{zip_filename}' is not a valid ZIP file.")
    except FileNotFoundError:
        log.error(f"Error: ZIP file '{zip_filename}' not found.")
    except Exception as e:
        log.error(f"An error occurred: {e}")
    if platform.system().lower().startswith("linux"):
        st = os.stat(full_name)
        os.chmod(full_name, st.st_mode | stat.S_IEXEC)
    return full_name
            
            
def find_inklecate() -> str:
    """
    Find the inklecate CLI tool in the system PATH or download it if not found.
    If the tool is not found in the PATH, it will attempt to download it from the official repository.

    :return:
        str the path to the inklecate executable.
    """
    inklecate_path = "inklecate"
    if platform.system().lower().startswith("windows"):
        inklecate_path += ".exe"
    try:
        inklecate_path = download_inklecate(inklecate_path)
    except Exception as e:
        print("Unable to download the CLI tools: {str(e)})\nTrying HERESY2_INKLECATE")
        if "HERESY2_INKLECATE" in os.environ:
            inklecate_path = os.environ.get("HERESY2_INKLECATE", inklecate_path)
    return inklecate_path  
    

def clean(remove_cli_tools: bool = False) -> None:
    """
    Clear out the "build" directory and remove any 'intermediate' build files
    :param remove_cli_tools: bool If True, remove the ink_tools directory as well.
    :return:
    """
    try:
        shutil.rmtree("build")
        if remove_cli_tools:
            shutil.rmtree("ink_tools")
        os.mkdir("build")
    except OSError:
        pass
    zipfile = f"heresy2_v{__version__.replace('.', '_')}.zip"
    build_files = ["tmp.json", os.path.join("src", "item_globals.ink"), zipfile]
    for filename in build_files:
        try:
            os.unlink(filename)
        except OSError:
            pass


def build() -> None:
    """
    Rebuild the "build" directory from scratch.

    :return:
    """
    # Complete rebuild
    clean()
    # Copy html and media directories
    shutil.copytree(os.path.join("src", "html"), "build", dirs_exist_ok=True)
    shutil.copytree(os.path.join("src", "media"), "build", dirs_exist_ok=True)
    # Build the story JSON file
    build_story_js()


def release() -> None:
    """
    Generate a zip file of the contents of the "build" directory.

    :return:
    """
    build()
    filename = f"heresy2_v{__version__.replace('.', '_')}.zip"
    with zipfile.ZipFile(filename, "w", zipfile.ZIP_DEFLATED) as zpf:
        for root, dirs, files in os.walk("build"):
            for file in files:
                src = os.path.join(root, file)
                arcname = os.path.relpath(src, os.path.join("build"))
                zpf.write(src, arcname=arcname)


def open_url(url: str) -> None:
    """open a URL in a new tab using webbrowser

    Args:
        url (str): the URL to open
    """
    webbrowser.open_new_tab(url)


def serve(port: int = 9000, nobrowser: bool = False) -> None:
    """start an HTML server for the current game build

    This will serve the contents of the "build" directory on the specified port.

    :param port: int  The port to run the HTML server on. Defaults to 9000.
    :param nobrowser: bool If true, do not attempt to open a web browser tab to the session. Defaults to False.

    :return: None
    """
    orig_cwd = os.getcwd()
    try:
        os.chdir("build")
        server_address = ('127.0.0.1', port)
        httpd = HTTPServer(server_address, SimpleHTTPRequestHandler)
        url = f"http://{server_address[0]}:{server_address[1]}"
        print(f"Serving story:  {url}")
        if not nobrowser:
            print(f"Opening a browsing tab.")
            bound_open_url = partial(open_url, url)
            timer = threading.Timer(5, bound_open_url)
            timer.start()
        httpd.serve_forever()
    except KeyboardInterrupt:
        pass
    finally:
        os.chdir(orig_cwd)
    print("Server stopped.")


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "-V",
        "--version",
        action="version",
        version="%(prog)s {version}".format(version=__version__),
    )
    parser.add_argument("--verbose", action="store_true", default=False, help="Run in verbose mode")
    parser.add_argument("--logfile", help="Log file for verbose output", default="")
    
    cmd_parsers = parser.add_subparsers(help="Command", dest="cmd")
    cmd_parsers.required = True

    build_parser = cmd_parsers.add_parser("build", aliases=["fullbuild"],
                                          help="Rebuild the entire build directory contents")

    clean_parser = cmd_parsers.add_parser("clean", help="Remove all build directory contents")

    serve_parser = cmd_parsers.add_parser("serve", help="Server the build via http")
    serve_parser.add_argument("--port", type=int, default=9000, help="The port to use. Default: 9000")
    serve_parser.add_argument("--nobrowser", action="store_true", default=False,
                              help="Do not automatically open a web browser tab to the server.")

    release_parser = cmd_parsers.add_parser("release", help="Rebuild & generate a tarball of 'build' directory")

    args = parser.parse_args()

    # Set up logging
    level = logging.INFO
    if args.verbose:
        level = logging.DEBUG
    log = logging.getLogger("heresy2_build")
    logging.basicConfig(filename=args.logfile, level=level)
    log.debug(f"Command line args: {args}")
    
    if args.cmd.endswith("build"):
        build()
    elif args.cmd == "release":
        release()
    elif args.cmd == "clean":
        clean(remove_cli_tools=True)
    elif args.cmd == "serve":
        serve(port=args.port, nobrowser=args.nobrowser)
    
    log.info("Operation complete")
    
    exit(0)

