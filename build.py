import argparse
import datetime
from functools import partial
import json
import threading
import tomllib
import webbrowser
import zipfile
from http.server import SimpleHTTPRequestHandler, HTTPServer
import logging
import os
import platform
import shutil
import subprocess
import requests

try:
    import git
    repo = git.Repo(".")
    branch_name = repo.active_branch.name
    branch_sha = repo.active_branch.commit.hexsha
    __version_git__ = f"Source: {branch_name}:{branch_sha}"
except:
    __version_git__ = ""


# Get the current version number
with open("version.txt", "r") as f:
    __version__ = f.read().strip()
    
# Get the current time/date
__version_date__ = datetime.datetime.now().isoformat(timespec='minutes', sep=" ") 
    
"""
Command line build tool:

python build.py [operation] [options]

Operations:

clean
build
fullbuild
release
serve [--port port] [--browse]

Note:

The 'inklecate' tool needs to be in the search path
and executable.  If it is not in the search path,
set HERESY2_INKLECATE to the complete pathname to the
executable.

"""


def build_story_js() -> None:
    """
    Rebuild the heresy2.js file in the build directory.

    First build the item_globals.ink and item_globals.js files
    from the items.toml file.

    :return:
    """
    # Get the story version
    with open("version.txt", "rb") as fp:
        version = fp.read()
    log.info(f"Story version: {version.decode('ascii')}")
    copyright_year = str(datetime.datetime.now().year).encode("utf8")
    # Generate the items content
    with open(os.path.join("src", "items.toml"), "r") as fp:
        info = tomllib.loads(fp.read())
    # create items_globals.js
    js = json.dumps(info)
    with open(os.path.join("build", "js", "item_globals.js"), "w", encoding='utf-8') as fp:
        fp.write(f"var storyItems = {js};\n")
        fp.write("var theStory = null;\n")
        fp.write("var audio = null;\n")
        fp.write("var audioLoop = null;\n")
        fp.write("let current_volume = 30;\n")
        fp.write("let last_volume = 30;\n")
        fp.write("var story_version = '" + version.decode('ascii') + "';\n")
    # create items_globals.ink
    with open(os.path.join("src", "item_globals.ink"), "w") as fp:
        fp.write("// This file is autogenerated from 'items.toml'.\n")
        fp.write("// Do not edit this file.\n")
        fp.write("\n// Items:\n")
        for name, data in info["items"].items():
            fp.write(f"VAR {name} = 0\n")
        fp.write("\n// States:\n")
        for name, data in info["states"].items():
            fp.write(f"VAR {name} = {data['default']}\n")
    # Generate the .json format of the root ink file
    inklecate_path = find_inklecate()
    cmd = [inklecate_path, "-o", "tmp.json", "-j", "-v", os.path.join("src", "heresy2.ink")]
    log.debug(f"Running compiler: {cmd}\n")
    try:
        result = subprocess.run(cmd, stdout=subprocess.PIPE)
    except FileNotFoundError:
        log.error(f"Could not run inklecate using path: {inklecate_path}.\nCheck your system PATH or HERESY2_INKLECATE environmental variable.")
        exit(-1)
    log.info(result.stdout.decode('utf-8'))
    # Build the Javascript from the JSON content
    with open("tmp.json", "rb") as fp:
        s = fp.read()
        s = b"var storyContent = " + s
        s = s.replace(b"STORY_VERSION", version)
        s = s.replace(b"STORY_YEAR", copyright_year)
        s = s.replace(b"STORY_GIT_BRANCH", __version_git__.encode("utf8"))
        s = s.replace(b"STORY_BUILD_DATE", __version_date__.encode("utf8"))
        with open(os.path.join("build", "js", "heresy2.js"), "wb") as output:
            output.write(s)


def download_file(url, filename):
    try:
        # Send a GET request to the URL, enabling streaming for large files
        response = requests.get(url, stream=True)
        response.raise_for_status()  # Raise an HTTPError for bad responses (4xx or 5xx)

        # Open the local file in binary write mode
        with open(filename, 'wb') as file:
            # Iterate over content in chunks to handle large files efficiently
            for chunk in response.iter_content(chunk_size=8192):
                file.write(chunk)
        log.info(f"File '{filename}' downloaded successfully from '{url}'")
        return True
    except requests.exceptions.RequestException as e:
        log.warning(f"Error downloading file from '{url}': {e}")
        return False


def download_inklecate(exe_name: str) -> str:
    # if "ink_tools/exe_name" exists, return that pathname, otherwise, rebuild the directory
    full_name = os.path.join("ink_tools", exe_name)
    if os.path.exists(full_name):
        return full_name
    try:
        shutil.rmtree("ink_tools")
    except OSError:
        pass
    os.mkdir("ink_tools")
    url = "https://github.com/inkle/ink/releases/download/v.1.2.0/inklecate_windows.zip"
    zip_filename = os.path.join("ink_tools", "inklecate_windows.zip")
    if not download_file(url, zip_filename):
        raise RuntimeError("Unable to download the inklecate CLI tools.")
    try:
        with zipfile.ZipFile(zip_filename, 'r') as zip_ref:
            zip_ref.extractall("ink_tools")
        log.info(f"All files extracted from '{zip_filename}' to 'ink_tools'.")
    except zipfile.BadZipFile:
        log.error(f"Error: '{zip_filename}' is not a valid ZIP file.")
    except FileNotFoundError:
        log.error(f"Error: ZIP file '{zip_filename}' not found.")
    except Exception as e:
        log.error(f"An error occurred: {e}")
    return full_name
            
            
def find_inklecate() -> str:
    inklecate_path = "inklecate"
    if platform.system().lower().startswith("windows"):
        inklecate_path += ".exe"
        inklecate_path = download_inklecate(inklecate_path)
    else:
        if "HERESY2_INKLECATE" in os.environ:
            inklecate_path = os.environ.get("HERESY2_INKLECATE", inklecate_path)
    return inklecate_path  
    

def clean() -> None:
    """
    Clear out the "build" directory and remove any 'intermediate' build files

    :return:
    """
    try:
        shutil.rmtree("build")
        os.mkdir("build")
    except OSError:
        pass
    zipfile = f"heresy2_v{__version__.replace('.', '_')}.zip"
    build_files = ["tmp.json", os.path.join("src", "item_globals.ink"), zipfile]
    for filename in build_files:
        try:
            os.unlink(filename)
        except OSError:
            pass


def build() -> None:
    """
    Rebuild the "build" directory from scratch.

    :return:
    """
    # Complete rebuild
    clean()
    # Copy html and media directories
    shutil.copytree(os.path.join("src", "html"), "build", dirs_exist_ok=True)
    shutil.copytree(os.path.join("src", "media"), "build", dirs_exist_ok=True)
    # Build the story JSON file
    build_story_js()


def release() -> None:
    """
    Generate a zip file of the contents of the "build" directory.

    :return:
    """
    build()
    filename = f"heresy2_v{__version__.replace('.', '_')}.zip"
    with zipfile.ZipFile(filename, "w", zipfile.ZIP_DEFLATED) as zpf:
        for root, dirs, files in os.walk("build"):
            for file in files:
                src = os.path.join(root, file)
                arcname = os.path.relpath(src, os.path.join("build"))
                zpf.write(src, arcname=arcname)

def open_url(url: str) -> None:
    """open a URL in a new tab using webbrowser

    Args:
        url (str): the URL to open
    """
    webbrowser.open_new_tab(url)
            
def serve(port: int = 9000, open: bool = False) -> None:
    """start an HTML server for the current game build

    Args:
        port (int, optional): The port to run the HTML server on. Defaults to 9000.
        open (bool, optional): If true, attempt to open a web browser tab to the session. Defaults to False.
    """
    orig_cwd = os.getcwd()
    try:
        os.chdir("build")
        server_address = ('127.0.0.1', port)
        httpd = HTTPServer(server_address, SimpleHTTPRequestHandler)
        url = f"http://{server_address[0]}:{server_address[1]}"
        print(f"Serving story:  {url}")
        if open:
            bound_open_url = partial(open_url, url)
            timer = threading.Timer(5, bound_open_url)
            timer.start()
        httpd.serve_forever()
    except KeyboardInterrupt:
        pass
    finally:
        os.chdir(orig_cwd)
    print("Server stopped.")


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "-V",
        "--version",
        action="version",
        version="%(prog)s {version}".format(version=__version__),
    )
    parser.add_argument("--verbose", action="store_true", default=False, help="Run in verbose mode")
    parser.add_argument("--logfile", help="Log file for verbose output", default="")
    
    cmd_parsers = parser.add_subparsers(help="Command", dest="cmd")
    cmd_parsers.required = True
    
    build_parser = cmd_parsers.add_parser("build", help="Regenerate the story .json file in the build directory")

    fullbuild_parser = cmd_parsers.add_parser("fullbuild", help="Rebuild the entire build directory contents")

    clean_parser = cmd_parsers.add_parser("clean", help="Remove all build directory contents")

    serve_parser = cmd_parsers.add_parser("serve", help="Server the build via http")
    serve_parser.add_argument("--port", type=int, default=9000, help="The port to use. Default: 9000")
    serve_parser.add_argument("--browse", action="store_true", default=False, help="Open a web browser tab to the server.")

    release_parser = cmd_parsers.add_parser("release", help="Rebuild & generate a tarball of 'build' directory")

    args = parser.parse_args()

    # Set up logging
    level = logging.INFO
    if args.verbose:
        level = logging.DEBUG
    log = logging.getLogger("heresy2_build")
    logging.basicConfig(filename=args.logfile, level=level)
    log.debug(f"Command line args: {args}")
    
    if args.cmd == "fullbuild":
        build()
    elif args.cmd == "build":
        build_story_js()
    elif args.cmd == "release":
        release()
    elif args.cmd == "clean":
        clean()
    elif args.cmd == "serve":
        serve(port=args.port, open=args.browse)
    
    log.info("Operation complete")
    
    exit(0)

